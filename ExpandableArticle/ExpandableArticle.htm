<!DOCTYPE HTML>
<!--------------------------------------------------------------------------->
<!--                           INTRODUCTION

 The CodeProject article submission template (HTML version)

Using this template will help us post your article sooner. To use, just
follow the 3 easy steps below:

     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets.

-->
<!--------------------------------------------------------------------------->
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
<title>CodeProject</title>
<Style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
BODY {padding:15px; }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
<link type="text/css" rel="stylesheet" href="Main.min.css">
</head>
<body bgcolor="#FFFFFF" color=#000000>
<!--------------------------------------------------------------------------->


<!-------------------------------     STEP 1      --------------------------->
<!--  Fill in the details (CodeProject will reformat this section for you) -->

<pre>
Title:       Expandable(P) Template
Description: Simple Data Structure for storage of multiple objects of a single class
Abstract:    How does one store multiple versions of a single class?  Use a hash table to get fast lookups but it
             can't be sorted.  Use a tree (balanced or otherwise) and the complexity of the code is significant.
             Sorting a tree multiple ways is also not trivial.  Use a linked list and sorting is really
             difficult.  Scanning a linked list backwards requires two pointers (also messy).

             Speed or efficiency are important in real time applications, not so much in Man-Machine
             Applications.  Expandable(P) takes the idea of a one column c++ array (i.e. a vector) in which
             the element is a class (i.e. the description of an object) and turns it into a storage vehicle.

Author:      Bob Van Tuyl
Email:       rrvt@swde.com

Language:    c++
Platform:    Any c++ platform
Technology:
Topic:       data

Section      c++ Tip or Trick
SubSection   ?

License:     Enter the license (<a href="http://www.codeproject.com/info/licenses.aspx">MIT</a>)
</pre>

<!-------------------------------     STEP 2      --------------------------->
<!--  Include download and sample image information.  -->

<ul class=download>
<!--
<li><a href="Article_demo.zip">Download demo project - XXX Kb</a></li>
-->
<li><a href="ExpandableExample.zip">Download Example Source - 83 Kb</a></li>
</ul>

<!--
<p><img src="Article.gif" alt="Sample Image - maximum width is 600 pixels" style="width:400px; height:200px"></p>
-->
<!-------------------------------     STEP 3      --------------------------->

<!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->
<h2>Preface to This Update</h2>

<p>
After writing the article and submitting it I went about updating several applications to use the new versions of
Expandable.  During that effort it became clear that the binary search implementation I put forward in the article
had a glaring flaw in that the equality test came first and uselessly for most of the search loop.  The second 
observation is the sorted insertion operator (e.g. data = datum; where data is an Expandable vector and datum is
a node to be inserted in the vector) could be improved by searching backwards through the vector so that if the 
data was already sorted the insertion would be a little more efficient.  The last observaion made during use of the
new versions of Expandable centered around the insertion.  The insertion sometimes involves copying the data from
one node to another as it is put into the vector.  However, it is sometimes useful to have a pointer to the node that
is in the vector after the insertion.  Thus I redefined the operator= and operator += to return a pointer to the 
resident node in the vector.  Most of the time it is not used, but sometimes it results in not having to perform a
search for the node one just put in the vector!
</p>


<h2>Introduction</h2>

<p>
Expandable is a template.  It provides a vector of objects that grows as needed.  It solves the problem
of reading a file of data of unknown length with a simple data structure.
Most of the overhead of using Expandable comes at the beginning
when the data structure is growing.  After that it may be treated as a c++ array (i.e. v[i], where v is
an Expandable object and i is an integer).  It may be sorted with quicksort.  It may be scanned by a simple
for loop.  If sorted it may be searched with a binary search.  Elements may be added or deleted at any time
using the same procedure as with a simple c++ vector (i.e. moving elements of the array as needed).
</p>

<p>
Unlike a simple c++ vector, the Expandable template can provide some of the procedural aspects of
addition and deletion
of elements in the vector at any position in the array.  In addition to adding a new element to the vector
at the end or at an index not at the end, an element may be added in a manner that sorts the data in the
vector.  (i.e. insertion sort).  Note the insertion sort also ensures that the insertions are unique.
</p>
<p>
Expanding the vector involves moving the data.  This could be expensive if the element is very large
so an alternative template, ExpandableP,
behaves very much like an Expandable object but only a pointer appears in the vector.  The rest of the
application sees the objects that are stored but the management of the pointer is left to ExpandableP.
</p>

<p>
When a class contains a single Expandable(P) object an iterator typedef may be defined by using the IterT
template.  The typedef may then be used to create an iterator that will return a pointer to each element
in the Expandable(P) object (i.e. scan the vector).
</p>

<p>
What is the programming cost of using an Expandable(P) object?
One cost is that the element in the vector must have a few
operations defined..  If an iterator typedef is defined, then the class holding the Expandable(P)
object will need a few very small operations (mostly private) and a friend declaration for the iterator
typename.
</p>

<p>
Expandable (both versions) manage the heap objects (allocating and deallocating) and executing the constructors
and destructors of the element objects at the proper times.  Assistance is provided by ExpandableP for
external allocation and deallocation of objects that are stored in the ExpandableP object if that becomes
desirable from a programming point of view.
</p>

<h2>Expandable(P) -- An expanding c++ Vector</h2>

<h3>Example Code</h3>
<p>
The code included is a simple console application that uses MFC.  Expandable(P) doesn't need MFC but it is useful
for other things in the example.
</p>
<p>
I've arranged the console application to demonstrate the various operations that may be performed with Expandable(P).  The code contains two versions of Store and one main function.  The examples may be
executed by specifying one or more command line arguments designating the operation to be performed
(i.e. <code>ExpandableExample Display Sort LoadSorted</code>).
Here is
a list of the operations that may be performed.
</p>
<ul>
<li>Display -- Simple array references for load and display</li>
<li>Sort -- Simple load into data, sort the array and then display the result</li>
<li>Append -- Load the vector with the append operator: <code>data += dtm;</code></li>
<li>LoadSorted -- Load the array with the insert unique object into sorted vector: <code>data = dtm;</code></li>
<li>IterDisplay -- Display vector using an iterator</li>
<li>BSearch -- Perform a sorted load and then do a binary search for every object in the Store object using the
key from each object.</lI>
<li>LinearSrch -- Perform a sorted load and then do a linear search for every object in the Store object using the
key from each object.</lI>
<li>LoadStoreP -- Load an ExpandableP object with a slightly more complex object for each line and 
display the resulting vector with an iterator.</li>
<li>LoadSortedP -- Load an ExpandableP object with the insertion sort option</lI>
<li>BSearchP -- Perform a sorted load and then do a binary search for every object in the StoreP object using the
key from each object.</lI>
<li>LinearSrchP -- Perform a sorted load and then do a linear search for every object in the Store object using the
key from each object.</lI>
</ul>
<p>
The code was compiled with Visual Studio 2017 (VS17) with the target being Win10 in the latest version of VS17.
The code was compiled using Unicode characters and the MFC dll library and my personal library.
The parent ExpandableExample directory contains a Solution Directory, ExpandableExample and a Project Directory,
ExpandableExample.prj.  The parent ExpandableExample directory should have the same parent as the Library
directory in order to compile with Visual Studio with no changes to the project properties.
</p>

<p>A short note on identifiers:</p>
<ul>
<li>A user defined class or typedef is capitalized (e.g. Store is a class)</li>
<li>A user defined object is not capitalized (e.g. store is an object)</li>
</ul>

<h3>The First Example -- Simple load and store into an Expandable Object</h3>
<h4>Store Header File (i.e. Store.h)</h4>
<p>
The header file defines data, an expandable vector.  The vector is initially 2 objects in length.  The object
in the vector is a line from the file and the line number.  The line number will be useful when the sort is performed.  Every object stored in an Expandable(P) object must contain a copy constructor, <code>Datum(Datum& dtm)</code>, and an copy assignment operator, <code>Datum& operator= (Datum& dtm)</code>.
</p>
<pre lang="C++" data-lang-orig="C++">
// Store Example


#pragma once
#include "Expandable.h"
#include "FileIO.h"


class Datum {

public:

ulong  key;                         // A 5 digit key created to be unique
String line;												// Line from the file

  Datum() : key(0) { }
  Datum(Datum& dtm) {copy(dtm);}

  Datum& operator=(Datum& dtm) {copy(dtm); return *this;}

private:

  void copy(Datum& dtm) {key = dtm.key;  line = dtm.line;}
  };


class Store {

String               path;
Expandable&lt;Datum, 2&gt; data;

public:

  Store() { }
 ~Store() { }

  void load(TCchar* filePath);

  void display();
  };


extern Store store;</pre>



<h4>Loading a File into Data</h4>
<p>
The simplest use of an Expandable(p) object is demonstrated in the following code that loads a file
into the "data" object.  My FileIO module interfaces with Windows through MFC to open and read from a file.
The key Expandable code is: <code>Datum& dtm = data[i];</code>.  It looks like an array reference, behaves
like an array reference but quietly expands the array when necessary.  The vector size is doubled
when it needs to expand.  Hopefully this mitigates the expense of finding the right size.
</p>


<pre lang="C++" data-lang-orig="C++">
void Store::load(TCchar* filePath) {
FileIO fil;
int    i;
String line;
Random rand(213);

  path = filePath;   data.clear();

  if (fil.open(path, FileIO::Read)) {
    wcout << filePath << " opened" << endl;

    for (i = 0; fil.read(line); i++) {
      Datum& dtm = data[i];
      ulong  r   = ulong(rand.next() * 1000.0);             // construct a random number

      dtm.key = r * 100 + i; dtm.line = line.trimRight();   // Shift the random number and make unique
      }
    }

  fil.close();
  }</pre>

<h4>Displaying the Data</h4>
<p>
Using a reference variable is unnecessary as the display function demonstrates.
</p>

<pre lang="C++" data-lang-orig="C++">
void Store::display() {
int    n = data.end();
int    i;
String s;

  for (i = 0; i < n; i++) {
    s.format(_T("%5i: "), data[i].key);

    wcout << s.str() << data[i].line.str() << endl;
    }
  }</pre>

<h4>Qsort requires a Vector and Two Datum Boolean Operators</h4>
<p>
Qsort operates on a vector.  Add the following code to the Store class:
<code>void sort() {qsort(&data[0], &data[data.end()-1]);}</code>,
call it and displaying the results will yield the file content sorted in the Expandable(P) object.  However,
when one attempts to compile the code, two functions will be missing from Datum:
</p>

<pre lang="C++" data-lang-orig="C++">
  bool operator>  (Datum& dtm) {return line >  dtm.line;}
  bool operator<= (Datum& dtm) {return line <= dtm.line;}
</pre>

<p>
Datum is sorted in this case by comparing the two lines of data but it could just as well be the unique keys created
during the load process.  Since Datum is a class composed by
the programmer the comparison can be anything desired.
</p>

<h4>Two Alternative Load Functions</h4>
<p>
Expandable(P) is a class so additional functions may be added to it.  Instead of computing <code>data[i]</code>
for each load, one can use the append operator <code>data += dtm</code>, where dtm is a Datum object.
</p>
<p>
If the objects in the vector are unique and two additional boolean operators are added to the
Datum class then  a Datum may be inserted into data sorted: <code>data = dtm</code>.  Here are
the two boolean operators required in Datum for this to work:
</p>

<pre lang="C++" data-lang-orig="C++">
  // Required for Insertion Sort, i.e. data = dtm;
  bool operator>= (Datum& dtm) {return key >= dtm.key;}
  bool operator== (Datum& dtm) {return key == dtm.key;}
</pre>

<p>
Note that in this case the unique key is used to sort the data on input.  This is done to support demonstrating
a binary search later.  If the Datum object is found in the vector during the insertion processing then it is not inserted.  This is required by the "uniqueness" clause.
</p>

<h3>Expandable Operations</h3>
<p>
Here is a list of the operations supported by Expandable:
</p>

<table width="100%" border="0">
  <tr>
    <td width="25%"><code>datum = data[i];</code></td>
    <td> Where 0 &lt;= i &lt; data.end() (i.e. endN)</td>
  </tr>
  <tr>
    <td><code>data[i] = datum;</code></td>
    <td>Array expands to encompass i</td>
  </tr>
  <tr>
    <td><code>data.clear();</code></td>
    <td>Content is ignored but number of elements (endN) is set to zero</td>
  </tr>
  <tr>
    <td><code>data.end();</code></td>
    <td>Returns the number of elements that contain Datum objects that have been added to the vector.</td>
  </tr>
  <tr>
    <td><code>data = datum;</code></td>
    <td>
    A unique datum is inserted into the sorted array at the correct position.
    The ">=" and "==" operators in the Datum class must be defined
    </td>
  </tr>
  <tr>
    <td><code>data += datum;</code></td>
    <td>Datum is appended to array (at new last element)</td>
  </tr>
  <tr>
    <td><code>Datum& d = data.nextData();<br/>
    data.nextData() = datum;</code></td>
    <td>
    A reference to new last element of array is returned.  It may used as shown or
    immediately with a dot operator or even as a target of an assignment (where a
    Datum operator= is defined)
    </td>
  </tr>
  <tr>
    <td><code>data(i, datum);</code></td>
    <td>Datum is inserted at index i, the contents at i and above are moved up one element</td>
  </tr>
  <tr>
		<td><code>Datum* d = find(key);</code></td>
    <td>
    	Perform a linear search of the Expandable object for a datum with a component with the same value as key.        
    </td>
  </tr>
  <tr>
		<td><code>Datum* d = bSearch(key);</code></td>
    <td>
      Perform a binary search of the Expandable object for a datum with a component with the same value as key.
    </td>
  </tr>
  <tr>
    <td><code>data.del(i);</code></td>
    <td>The datum at index i is deleted and the elements above are moved down to fill in the hole.  
    The number of elements in the array is reduced by one</td>
  </tr>
</table>

<h3>Cautions</h3>

<p>
C++ allows the address of an array (i.e. vector) to be placed in a pointer defined by the class
that inhabits the vector: <code>Datum* p = &data[0]</code> or <code>Datum* p = data</code>.
There is nothing wrong with using a pointer as illustrated, however, incrementing the pointer indiscriminately may result in a memory violation.
</p>
<p>
  Expandable copies
the old vector into a new vector when it needs to expand.  So getting a pointer or reference to
a Datum object in the vector is only good until the next addition to the array.  Most of the time
the pointer will be valid but there will be that one time when holding a pointer while adding
an entry into the array and the application will crash with an exception.  The code will look
good and it will not work and  it will be hard to debug.  So the rule is:  Pointers/references to
Expandable element objects are only good if there are no insertions while the pointer/reference
is active, period!
</p>
<p>
The pointer problem mentioned above is solved by ExpandableP with some additional memory overhead.
See the description of ExpandableP below.
</p>

<h3>Iterator</h3>

<p>
The typical loop uses an index and an array reference using the index:
</p>

<pre lang="C++" data-lang-orig="C++">
    for (i = 0; i < data.end(); i++) {
    Datum& dtm = data[i];
    o o o</pre>

<p>
Another method for performing a loop uses an iterator.  An iterator template is defined for
the class in which a single Expandable(P) object is defined.  If the Iterator typedef for
data is StoreIter then this is how it would be used:
</p>
<pre lang="C++" data-lang-orig="C++">
void Store::display2() {
StoreIter iter(*this);
Datum*    dtm;
String    s;

  for (dtm = iter(); dtm; dtm = iter++) {
    s.format(_T("%3i/%5i: "), iter.index(),  dtm->key);

    wcout << s.str() << dtm->line.str();
    }
  }</pre>
<h4>Iterator Declaration</h4>
<p>
The iterator for a class holding an Expandable object is specialized for the class.  This means that
the IterT is a class template.  Furthermore, we may need two or more iterators in the same function for
the same Expandable(p) object so the template defines a typedef.  Here is how the Iterator for Store is defined:
</p>

<pre lang="C++" data-lang-orig="C++">
class Store;
typedef IterT&lt;Store, Datum&gt; StoreIter;</pre>

<p>
These declarations are placed after the Datum class and before the Store class.  When the iterator is
to be used it must be defined with the name of an object of class Store (note: capitalized).
In the example there is one
Store object and it is called "store" (note, not capitalized).  Here are the two declarations needed
to use the iterator:
</p>
<pre lang="C++" data-lang-orig="C++">
StoreIter iter(store);
Datum*    dtm;</pre>
<p>
Of course within a Store function, the Store object may be represented as <code>*this</code>.
</p>

<p>
So an iterator does not operate in a vacuum.  The Store class requires a few little functions and a friend
declaration. Here they are:
</p>

<pre lang="C++" data-lang-orig="C++">
class Store {

    o o o

private:

  // returns either a pointer to data (or datum) at index i in array or zero

  Datum* datum(int i) {return 0 <= i && i < nData() ? &data[i] : 0;}       // or data[i].p

  int   nData()      {return data.end();}                       // returns number of data items in array

  void  removeDatum(int i) {if (0 <= i && i < nData()) data.del(i);}

  friend typename StoreIter;</pre>

<p>
The IterT.h header file contains a comment in which these functions may be found.  The names
of the Expandable(P) object and the Datum object will need to be changed.
</p>

<h4>Iterator Functions</h4>

<table width="100%" border="0">
  <tr>
    <td width="26%">
    <code>StoreIter iter(store);<br/>
    Datum*&nbsp;&nbsp;&nbsp;&nbsp;dtm;</code>
    </code></td>
    <td>Initialization Constructor which names the object in which the Expandable object resides</td>
  </tr>
  <tr>
    <td><code>StoreIter jter(iter);</code></td>
    <td>Copy constructor which initializes jter to the current state of iter.</td>
  </tr>
  <tr>
    <td><code>
    dtm = iter(Fwd) or iter();<br/>
    dtm = iter(Rev);
    </code></td>
    <td>
    Initialize iterator in the forward (i.e. Fwd) or reverse (i.e. Rev) direction, defaults to Fwd.
    Returns a p[pointer the first element of the scan or zero.
    </td>
  </tr>
  <tr>
    <td><code>dtm = iter++;</code></td>
    <td>
    Increments the scan index if less than the end of the vector and returns a pointer to the next
    element of the vector or zero.
    </td>
  </tr>
  <tr>
    <td><code>dtm = iter--;</code></td>
    <td>Decrements the scan index if greater than zero and returns a pointer to the next element of the
    vector or zero.
    </td>
  </tr>
  <tr>
    <td><code>int index = iter.index();</code></td>
  <td>returns the current index in the iterator, it may not be a legal index</td>
  </tr>
  <tr>
    <td><code>dtm = iter. current();</code></td>
    <td>Returns the current element of the vector or zero</td>
  </tr>
  <tr>
    <td><code>if (iter.isLast()) ...</code></td>
    <td>Returns true if the current element is at the largest index containing elements</td>
  </tr>
  <tr>
    <td><code>if (iter.isFirst()) ...</code></td>
    <td>Returns true if current element is at the zero index</td>
  </tr>
  <tr>
    <td><code>iter.remove(Fwd) or remove();<br/>
    iter.remove(Rev);
    </code></td>
    <td>
    Remove the current element from the vector and adjust the iterator index according to the
    direction.
    </td>
  </tr>
</table>

<h3>Linear and Binary Searches</h3>

<p>
The Expandable(P) function &quot;find&quot; performs a linear search for a key and &quot;bSearch&quot; performs a binary search for a key.  Actually, they are both templates that allow any key type to be used.  Of course they both use
boolean operations on the Datum object that must be defined.  They return a pointer to a Datum object of zero.
</p>

<pre lang="C++" data-lang-orig="C++">
template&lt;class Key&gt;
Data* find(Key key) {
  o o o
  }
  
template&lt;class Key&gt;     
Data* bSearch(Key key) {
  o o o
  }</pre>

<p>
Here are the boolean operations that must appear in the Datum object for the two searches (only equaility is needed
for the linear search):
</p>
<pre lang="C++" data-lang-orig="C++">
  // Required for Binary Search
  bool     operator== (ulong key) {return this->key == key;}      // Required for linear search
  bool     operator<  (ulong key) {return this->key <  key;}
  bool     operator>  (ulong key) {return this->key >  key;}</pre>

<h3>ExpandableP</h3>

<p>
When the class used in an Expandable(P) vector is large the cost of expanding the vector becomes
fairly large.  For example:
</p>

<pre lang="C++" data-lang-orig="C++">
class Words {
public:

String zero;
String one;
String two;
String three;
String rest;

  Words() { }
  Words(Words& wrds) {copy(wrds);}
 ~Words() { }

  Words& operator= (Words& wrds) {copy(wrds); return *this;}

  void load(String& line);

  void display();

private:

  void copy(Words& wrds);

  bool nextWord(String& s, String& word);
  };</pre>

<p>
For this example I intend to trim the line of leading and trailing spaces, tabs and end of line characters.  Then
when loading the file the first four words are placed in the Strings zero, one, two and three with the rest of
of the line in the String rest.
</p>
<p>
ExpandableP solves the expensive copy issue at the cost on one pointer for every object in the array. On the plus
side, since the pointers are moved (and not the Datum objects) the getting a pointer to an object in
the ExpandableP vector is
permanent until the element is deleted.  That is, no worries about possessing a <code>Datum* ptr</code> and
inserting new elements anywhere in the ExpandableP vector.
</p>

<p>It is used
in almost the same manner as Expandable but has some additional functions.  The declaration of the ExpandableP object
is a bit more complex.  The RcdPtrT template provides all the operations needed by ExpandableP to manage the Words
objects in the vector.
</p>

<pre lang="C++" data-lang-orig="C++">
typedef RcdPtrT&lt;Words&gt; WordsP;


class StoreP {

ExpandableP&lt;Words, WordsP, 2&gt; data;

public:
  o o o</pre>

<p>
The iterator is defined in the same way for an ExpandableP object but the private datum function is defined a bit differently:
</p>
<pre lang="C++" data-lang-orig="C++">
class StoreP;
typedef IterT&lt;StoreP, Words&gt; StorePIter;

class StoreP {

ExpandableP&lt;Words, WordsP, 2&gt; data;
  o o o
private:

  // returns either a pointer to data (or datum) at index i in array or zero

  Words* datum(int i) {return 0 <= i && i < nData() ? data[i].p : 0;}       // note: data[i].p</pre>
<p>
With Expandable, datum includes the expression <code>&data[i]</code>.  ExpandableP includes the expression
<code>data[i].p</code>.
</p>

<h3>ExpandableP Operations</h3>

<table width="100%" border="0">
  <tr>
    <td width="26%"><code>datum = data[i];</code></td>
    <td>where 0 &lt;= i &lt; data.end() (i.e. endN)</td>
  </tr>
  <tr>
    <td><code>data[i] = datum;</code></td>
    <td>array expands to encompass i</td>
  </tr>
  <tr>
    <td><code>data.clear();</code></td>
    <td>content is ignored but number of elements is set to zero</td>
  </tr>
  <tr>
    <td><code>data.end();</code></td>
    <td>returns the number of elements that contain Datum objects that have been added to the vector.</td>
  </tr>
  <tr>
    <td><code>data = datum;<br/>data = &datum;</code></td>
    <td>
    A unique datum is copied into an allocated heap node and then inserted into the sorted vector at the 
    correct position.  If the datum already exists in the vector then the function merely returns.
    The ">=" and "==" operators in datum must be defined
    </td>
  </tr>
  <tr>
    <td><code>data += &datum;</code></td>
    <td>
    A pointer to a datum is considered to be an already allocated (see allocate() below) object and is
    appended to the array
    </td>
  </tr>
  <tr>
    <td><code>data += datum;</code></td>
    <td>
    A object is assumed to be a local variable and not already allocated in the heap.  So a record is
    allocated and datum is copied to the new record.  The new record is appended to array (at new last
    element)
    </td>
  </tr>
  <tr>
    <td><code>Datum& d = data.nextData();<br/>
      data.nextData() = datum;</code></td>
    <td>
    A new record is allocated and stored in the new last element of array.  A reference to the new record
    is returned.  It may used as shown or immediately with a dot operator or even as a target of an
    assignment (where a Datum operator= is defined)
    </td>
  </tr>
  <tr>
    <td><code>Datum& d = data.getData(i);</code></td>
    <td>return a reference to a record at index i allocating a record if necessary</td>
  </tr>
  <tr>
    <td><code>data(i, datum);</code></td>
    <td>
    datum is inserted at index i, the contents at i and above are moved up one element.
    A new record is allocated and datum copied into the new record.
    </td>
  </tr>
  <tr>
    <td><code>data(i, &datum);</code></td>
    <td>
    The pointer indicates that the record has already been allocated and it is inserted at index i, the
    contents at i and above being moved up one element.
    </td>
  </tr>
  <tr>
		<td><code>Datum* d = find(key);</code></td>
    <td>
    	Perform a linear search of the ExpandableP object for a datum with a component with the same value as key.        
    </td>
  </tr>
  <tr>
		<td><code>Datum* d = bSearch(key);</code></td>
    <td>
      Perform a binary search of the ExpandableP object for a datum with a component with the same value as key.
    </td>
  </tr>
  
  <tr>
    <td><code>data.del(i);</code></td>
    <td>
    The datum at index i is deleted and the elements above are moved down to fill in the hole.  The
    number of elements in the array is reduced by one
    </td>
  </tr>
  <tr>
    <td><code>Datum* d = data.allocate();</code></td>
    <td>Allocate one record and return a pointer to it</td>
  </tr>
  <tr>
    <td><code>data.deallocate(&datum);</code></td>
    <td>Deallocate one record</td>
  </tr>
  <tr>
    <td><code>RcdPtr* rcdP = data.getRcdPtr(i);</code></td>
    <td>
    Returns a pointer to a RcdPtr class.  This should be used sparingly if at all.  I used it once to
    deal with deallocating a case where the pointer in RcdPtr contained a base pointer with two variants.
    Thus, the standard deallocation scheme failed to release all the memory since it only know about the
    base class
    </td>
  </tr>
</table>

<p>
Since all the Words objects are stored in heap nodes, there are some additional functions to allocate, add and
deallocate Words nodes.  This gives the programmer some additional flexibility with respect to creating nodes.
It should also be noted that Words constructors are executed during creation of the node.
When the node is contained in
the vector and the entire ExpandableP vector is deleted and/or an element of the vector is deleted the corresponding destructors are
called.  The object itself is responsible for construction and destructing all of its components.  Note, the String
component has its own constructor and destructor.  Simple integer, doubles, etc. do not require constructor and
destructors.  If there is allocated heap objects in the Datum object the the Datum destructor is responsible
for deallocating the heap objects.
</p>


<h2>Conclusion</h2>

<p>
When I was studying Computer Science a long time ago we created elaborate data structures to optimize time and space.
The more complex data structures were a marvel, ... but with complexity comes difficulty getting them right all the time.  I once spent about a week looking for a bug that would occur after executing the code for 45 minutes.  The code
was large and complex and had been modified by someone in the previous year or so.  The fix:  move two statements from
one class to two daughter classes.  The moral of this story is keep the code simple.
</p>
<p>
Expandable(P) grew out of a simple hash table which when it was around 80% full would be increased in size.  It was
implemented in a vector similar to an Expandable vector.  In that case the move was done by rehashing each entry into
the new space.  The trick was that the heap was managed by the application so the hash table was increased by merely
adding a chunk of memory to the existing table.  The rehash took an entry to the same place or somewhere else in the
expanded table.
</p>
<p>
The libraries included with Visual Studio 2017 provide some storage classes and I have used one in an important
application.  It allows the data store to be defined, provides an iterator or other functions.  It might be
implemented as a tree too.  Do I trust it, yes.  It just seemed clumsy to me.  It returned a tuple sometimes, which I
had to translate into something useful in the program.  Did I use it again in another application, nope.  I
reinvented the wheel that I perceived to be simpler and provided just the services that I needed.
</p>


<!-------------------------------    That's it!   --------------------------->
</body>

</html>

